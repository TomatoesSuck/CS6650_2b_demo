/*
 * E-commerce API
 *
 * API for managing products, shopping carts, warehouse operations, and credit card processing
 *
 * API version: 1.0.0
 * Contact: support@example.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package api

import (
	"net/http"
	"strconv"
	"sync"

	"github.com/gin-gonic/gin"
)

type ProductsAPI struct {
}

var productStore sync.Map

func init() {
	productStore.Store(int(12345), Product{
		ProductId:    12345,
		Sku:          "ABC-123-XYZ",
		Manufacturer: "Acme Corporation",
		CategoryId:   456,
		Weight:       1250,
		SomeOtherId:  789,
	})

	productStore.Store(50000, "this is not a Product")
}

func writeErr(c *gin.Context, status int) {
	c.JSON(status, gin.H{
		"error":   "INVALID_INPUT",
		"message": "The provided input data is invalid",
		"details": "Product ID must be a positive integer",
	})
}

// Get /v1/products/:productId
// Get product by ID
func (api *ProductsAPI) GetProduct(c *gin.Context) {
	idStr := c.Param("productId")
	id, err := strconv.Atoi(idStr)

	// Invalid ID is treated as "not found" → 404
	if err != nil || id < 1 {
		writeErr(c, http.StatusNotFound)
		return
	}

	// If product not found, return 404
	val, ok := productStore.Load(id)
	if !ok {
		writeErr(c, http.StatusNotFound)
		return
	}

	// If type assertion fails → 500 (internal server error)
	p, ok := val.(Product)
	if !ok {
		writeErr(c, http.StatusInternalServerError)
		return
	}

	c.JSON(http.StatusOK, p)
}

// Post /v1/products/:productId/details
// Add product details
func (api *ProductsAPI) AddProductDetails(c *gin.Context) {
	idStr := c.Param("productId")
	// Convert the productId from string to integer
	id, err := strconv.Atoi(idStr)

	// If the conversion fails or productId < 1,
	// it means the client sent an invalid path parameter.
	// For POST requests, this should return a 400 Bad Request response.
	if err != nil || id < 1 {
		writeErr(c, http.StatusBadRequest)
		return
	}

	// simulate encounter panic
	if id == 99999 {
		panic("simulate internal error")
	}

	// Try to bind (parse) the incoming JSON payload into a Product struct.
	// If the body is not valid JSON, or the field types don't match the struct definition,
	// return a 400 Bad Request response.
	var body Product
	if err := c.ShouldBindJSON(&body); err != nil {
		writeErr(c, http.StatusBadRequest)
		return
	}

	// Business validation (minimal required fields according to the schema)
	if body.Sku == "" || body.Manufacturer == "" || body.CategoryId < 1 || body.Weight < 0 || body.SomeOtherId < 1 {
		writeErr(c, http.StatusBadRequest)
		return
	}

	// If product_id is provided in the JSON body, it must match the productId from the URL path.
	// This ensures data consistency — the client cannot send a mismatched ID.
	// Example:
	//   POST /v1/products/12345/details
	//   Body: { "product_id": 99999, ... }
	if body.ProductId != 0 && int(body.ProductId) != id {
		writeErr(c, http.StatusBadRequest)
		return
	}

	// The target product must already exist, otherwise return 404
	if _, ok := productStore.Load(id); !ok {
		writeErr(c, http.StatusNotFound)
		return
	}

	// Recover from unexpected panic → 500
	defer func() {
		if r := recover(); r != nil {
			writeErr(c, http.StatusInternalServerError)
		}
	}()

	// Regardless of whether product_id is provided in the request body, use the productId from the path parameter
	// this is in case client doesn't include id in their request body
	body.ProductId = int32(id)
	productStore.Store(id, body)

	// Successful response as per spec: 204 No Content (no response body)
	c.Status(http.StatusNoContent)
}
